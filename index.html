<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 Pseudo-3D Kart Engine</title>
    <style>
        body {
            margin: 0; background-color: #111; display: flex;
            justify-content: center; align-items: center;
            height: 100vh; color: white; font-family: sans-serif; flex-direction: column;
        }
        canvas {
            border: 4px solid #fff; box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            border-radius: 8px; background-color: #87CEEB;
        }
        .instructions { margin-top: 15px; text-align: center; }
    </style>
</head>
<body>

    <h2>Albert Park Karting</h2>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="instructions">
        <p><strong>Controls:</strong> ⬆️ Gas | ⬇️ Brake | ⬅️ ➡️ Steer</p>
        <p><em>Careful! Turns will push your kart outward. Don't fall in the lake!</em></p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        // --- TRACK BUILDER (Albert Park Inspiration) ---
        const track = [];
        function addRoad(enter, hold, leave, curve) {
            for(let i=0; i<enter; i++) track.push({ curve: curve * (i/enter) });
            for(let i=0; i<hold; i++) track.push({ curve: curve });
            for(let i=0; i<leave; i++) track.push({ curve: curve * (1 - i/leave) });
        }
        
        // Building the Circuit Lap
        addRoad(50, 150, 50, 0);     // Pit Straight
        addRoad(20, 40, 20, 1.8);    // Turn 1 (Hard Right)
        addRoad(20, 40, 20, -1.8);   // Turn 2 (Hard Left Chicane)
        addRoad(40, 100, 40, 0);     // Short Straight
        addRoad(30, 60, 30, 2.2);    // Turn 3 (Sharp Right)
        addRoad(40, 80, 40, 0);      // Straight
        addRoad(50, 100, 50, -1.2);  // Sweeping Left
        addRoad(40, 120, 40, 0);     // Back Straight
        addRoad(30, 50, 30, 2.5);    // High-speed Right Chicane
        addRoad(30, 50, 30, -2.5);   // High-speed Left Chicane
        addRoad(50, 150, 50, 0);     // Final straight to finish line

        // Game State
        let position = 0; 
        let speed = 0;
        let maxSpeed = 180;
        let playerX = 0; 
        const segmentLength = 200;
        let respawnTimer = 0;
        let crashMessage = "";

        function drawPolygon(x1, y1, w1, x2, y2, w2, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x1 - w1, y1); ctx.lineTo(x1 + w1, y1);
            ctx.lineTo(x2 + w2, y2); ctx.lineTo(x2 - w2, y2);
            ctx.fill();
        }

        function update() {
            if (respawnTimer > 0) {
                respawnTimer--;
                speed = 0;
                if (respawnTimer === 0) playerX = 0; // Drop back in center of track
                return;
            }

            let currentSeg = track[Math.floor(position / segmentLength) % track.length];

            // Acceleration & Friction
            if (keys['ArrowUp']) speed += 2;
            else if (keys['ArrowDown']) speed -= 3; // Brakes
            else speed *= 0.97; 

            speed = Math.max(-30, Math.min(speed, maxSpeed));

            // Steering & Centrifugal Force (Curves push you outward)
            if (Math.abs(speed) > 1) {
                let steerAmount = 0.04 * (speed / maxSpeed);
                if (keys['ArrowLeft']) playerX -= steerAmount;
                if (keys['ArrowRight']) playerX += steerAmount;
                
                // Centrifugal force based on current track curve
                playerX -= (speed / maxSpeed) * currentSeg.curve * 0.03; 
            }

            // Terrain limits (Walls and Falling Off)
            if (Math.abs(playerX) > 2.8) {
                // Fell in the lake!
                respawnTimer = 90; // 1.5 seconds timeout
                crashMessage = "SPLASH! You fell in the lake!";
                speed = 0;
            } else if (Math.abs(playerX) > 1.2) {
                // Driving on Grass (Slow down significantly)
                speed *= 0.90; 
            }

            position += speed;
            if (position < 0) position = 0;
        }

        function draw() {
            // Sky
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, width, height / 2);

            let startSeg = Math.floor(position / segmentLength);
            let offset = position % segmentLength;
            
            let segmentsToDraw = [];
            let dx = 0; // Curve drift
            let ddx = 0; // Curve severity

            // 1. Calculate the 3D projection for the next 50 segments
            for (let n = 0; n < 50; n++) {
                let segIndex = (startSeg + n) % track.length;
                let seg = track[segIndex];
                
                ddx += seg.curve;
                dx += ddx;
                
                let z = (n * segmentLength) - offset;
                if (z < 1) z = 1; // Prevent division by zero
                let scale = 400 / z;
                
                segmentsToDraw.push({
                    y: (height / 2) + (scale * 120),
                    w: scale * 300, // Road width
                    x: (width / 2) + ((dx - playerX * 300) * scale), // Screen center + curve + player position
                    isLight: (Math.floor(segIndex / 3) % 2 === 0)
                });
            }

            // 2. Draw the segments from BACK to FRONT (Painter's Algorithm)
            for (let i = segmentsToDraw.length - 2; i >= 0; i--) {
                let s1 = segmentsToDraw[i];   // Closer to camera
                let s2 = segmentsToDraw[i+1]; // Further away
                
                let c = s1.isLight ? 
                    { grass: '#2ecc71', road: '#7f8c8d', rumble: '#ecf0f1', lake: '#2980b9' } :
                    { grass: '#27ae60', road: '#95a5a6', rumble: '#e74c3c', lake: '#2471a3' };

                // Draw Lake (Base layer)
                ctx.fillStyle = c.lake;
                ctx.fillRect(0, s2.y, width, s1.y - s2.y + 1);

                // Draw Grass Islands
                drawPolygon(s1.x, s1.y, s1.w * 3.5, s2.x, s2.y, s2.w * 3.5, c.grass);

                // Draw Rumble Strips
                drawPolygon(s1.x, s1.y, s1.w * 1.1, s2.x, s2.y, s2.w * 1.1, c.rumble);

                // Draw Asphalt Road
                drawPolygon(s1.x, s1.y, s1.w, s2.x, s2.y, s2.w, c.road);
            }

            // 3. Draw the Kart
            ctx.save();
            ctx.translate(width / 2, height - 90);
            
            if (respawnTimer > 0) {
                // If crashed, make the kart blink
                ctx.globalAlpha = (Math.floor(Date.now() / 100) % 2 === 0) ? 1 : 0.3;
            } else {
                // Lean into turns
                let currentCurve = track[Math.floor(position / segmentLength) % track.length].curve;
                ctx.rotate(currentCurve * 0.1);
            }

            ctx.fillStyle = '#222'; ctx.fillRect(-55, -20, 25, 45); ctx.fillRect(30, -20, 25, 45); // Tires
            ctx.fillStyle = '#c0392b'; ctx.fillRect(-40, -30, 80, 50); // Body
            ctx.fillStyle = '#2980b9'; ctx.fillRect(-20, -70, 40, 40); // Driver body
            ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.arc(0, -75, 22, 0, Math.PI * 2); ctx.fill(); // Driver Hat

            ctx.restore();

            // 4. UI Overlays
            if (respawnTimer > 0) {
                ctx.fillStyle = "white";
                ctx.font = "bold 40px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText(crashMessage, width/2, height/2 - 50);
            }

            // Speedometer
            ctx.fillStyle = "white";
            ctx.font = "24px sans-serif";
            ctx.textAlign = "left";
            ctx.fillText(`SPEED: ${Math.floor(speed)} MPH`, 20, 40);
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        loop();
    </script>
</body>
</html>
